

\chapter{Un registro delle compilazioni}
\label{iiichRegistro}

Siamo giunti al primo capitolo di taglio applicativo. Ci occuperemo di creare
in Lua un sistema di registrazione delle compilazioni che si concretizza in un
file posizionato nella directory principale del progetto di documento.

Non è possibile reperire dati generali sulla compilazione eseguendo codice
durante la compilazione stessa. Dovremo farlo con un tool esterno. Solo in
questo modo è possibile ottenere il tempo di compilazione totale o accertarsi
del nome del file sorgente. Tuttavia la registrazione in fase di compilazione è
utile per imparare con Lua a lavorare con i file e sperimentare un processo di
sviluppo iterativo molto più rapido che con \TeX.

Chiameremo questo registro \code{history.log} verso cui invieremo una linea di
testo informativa per ciscuna compilazione che il compositore completi
correttamente.


\section{Scrivere sul registro}

Iniziamo a implementare la gestione automatica del registro dalla funzionalità
chiave: la scrittura su file. Ci rivolgeremo alla libreria standard di Lua,
modulo \code{io}\footnote{La completa documentazione della libreria \code{io} si
trova alla pagina \url{https://www.lua.org/manual/5.3/manual.html\#6.8}.}:
\begin{lines}
-- write a line of text in a file
local function append(filename, line)
    local f = io.open(filename, "a+")
    f:write(line.."\n")
    f:close()
end
\end{lines}

La funzione \fn{io.open} restituisce un riferimento a un oggetto che rappresenta
un canale di input/output del sistema operativo verso un file i cui metodi vanno
chiamati in colon notation (vedi alla sezione~\ref{secRectOop}). \fn{open}
accetta il nome e la modalità di apertura del file. Lo specificatore \verb|"a+"|
indica di aprire il file in \emph{append} senza distruggerne il contenuto
preesistente. In caso il file non esista ne verrà creato uno nuovo perciò in
ogni caso otterremo il file aperto in scrittura.

La funzione \fn{append} può essere provata in un sorgente plain \LuaTeX{}
compilabile come in questo:
\sourcecode{file = [[app-registro/01.tex]]}


\section{Dati di compilazione}

Costruite le fondamenta stabiliamo quali dati inserire nel registro: l'utente 
mano a mano che il lavoro sul documento procede eseguirà senza dubbio delle
compilazioni intermedie perciò registreremo le seguenti informazioni di base:
\begin{compactenumerate}
\item il nome del file sorgente,
\item la dimensione del file sorgente,
\item data e ora della compilazione,
\item il tempo di esecuzione della composizione,
\item il nome del motore di composizione.
\end{compactenumerate}

Per formare la linea di registro, al posto della concatenazione di stringhe
useremo quella di una tabella di stringhe, più efficiente. Riempiremo la tabella
un dato alla volta in un blocco \cs{directlua} posizionato immediatamente prima
del termine del sorgente. Come prima istruzione invece, inseriremo il blocco di
codice Lua che definirà alcuni parametri come il nome del file del registro e il
separatore di campo testuale, e la funzione \fn{append}:
\sourcecode{file = [[app-registro/02.tex]]}


\subsection{La variabile \code{jobname}}

Il nome del file sorgente non è detto che sia contenuto nella variabile
\code{jobname} che possiamo trovare anche nella macro omonima oppure nel campo
omonimo della tabella \code{tex}.

Il campo o la macro conterrà il nome del sorgente soltanto se l'utente non ha
valorizzato l'opzione \code{--jobname} nel comando di compilazione con un altro
nome o se non è stato modificato il campo \code{tex.jobname}.

Infatti, se provassimo a compilare il listato \code{02.tex} con il seguente
comando
\begin{Verbatim}[numbers=none,xleftmargin=0pt]
$ luatex --jobname=abc 02
\end{Verbatim}
otterremo un errore che blocca la compilazione. Nel secondo \cs{directlua} la
variabile locale \key{jobname} conterrebbe infatti la stringa \code{abc.tex}
che è un file che non esiste. Di conseguenza la funzione \fn{lfs.attributes}
restituisce \key{nil} che ovviamente non può essere indicizzato con la chiave
\key{size}.

La tabella \code{lfs} contiene la libreria Lua File System disponibile per i
sistemi operativi più diffusi, con alcune funzionalità sui file che non troviamo
di base in Lua perché l'interprete ha regole stringenti di portabilità. La
troviamo in \LuaTeX{} già compilata staticamente. La documentazione si trova
all'indirizzo web
\url{https://keplerproject.github.io/luafilesystem/manual.html}.

Se la funzione \fn{lfs.attributes} non restituisce la tabella con i dati del
file significa dunque che nel comando di compilazione è stata attivata l'opzione
\code{--jobname} per assegnare un diverso nome al file PDF di uscita.
Modifichiamo dunque il codice eseguito in chiusura in questo senso:
\begin{lines}
local tline = {}
local jobname = tex.jobname
local attr = lfs.attributes(jobname..".tex")
if attr then
    tline[1] = jobname
    tline[2] = attr.size
else
    tline[1] = "unknow"
    tline[2] = "unknow"    
end
tline[3] = os.date()
tline[4] = os.clock() - register.start
tline[5] = status.luatex_engine
register:append(tline)
\end{lines}

Anche l'estensione \code{.tex} è un problema perché se fosse diversa ancora una
volta il codice non funzionerebbe, per esempio se il file sorgente avesse
estensione \code{.TEX}.


\subsection{Gli altri dati}

Come sappiamo dal capitolo~\ref{iiChLibstd} la tabella \key{os} appartiene alla
libreria standard di Lua. La documentazione delle funzioni \fn{os.date} e
\fn{os.clock} si trova quindi nel reference ufficiale del linguaggio alla pagina
\url{https://www.lua.org/manual/5.3/manual.html#6.9}.

Infine, maggiori informazioni sulla tabella \key{status} da cui leggiamo il nome
del motore di composizione, possono essere reperite nel manuale di \LuaTeX{}.

Quanto alla misura del tempo di compilazione che registriamo, più precisamente
si tratta del tempo che trascorre tra i due momenti in cui eseguiamo la funzione
\fn{os.clock} perciò non comprende il tempo iniziale di avvio e caricamento del
formato, né i tempi finali di chiusura come la composizione del materiale non
ancora emesso sulla pagina.


\section{Creare il modulo e il pacchetto}

Per consentire l'utilizzo del registro da qualsiasi sorgente occorre spostare il
codice Lua in un file esterno di \emph{modulo} e scrivere un secondo file di
\emph{pacchetto} per fornire un'interfaccia utente conforme al formato, per
esempio per \LaTeX{}.

Questa separazione non è solo utile al processo di sviluppo, facilitando
l'accesso alle funzionalità da parte degli utenti indipendentemente dal formato.

Allo stato attuale dello sviluppo del codice, il modulo Lua è il seguente:
\sourcecode{file = [[app-registro/mod-history.lua]]}

Tutte le funzionalità sono incluse in un unica tabella Lua chiamata
\code{register}. Dall'esterno, caricando il modulo con la funzione \fn{require}
potremo assegnarne il riferimento a una variabile locale o globale a seconda
delle necessità.

L'uso della colon notation per chiamare le funzioni non fa parte di
un'implementazione a oggetti ma è solo un semplice modo per poter disporre di un
riferimento alla tabella contenitore con la chiave \key{self}. Ciò rende pulito
il codice ed elimina la necessità di creare una closure con un piccolo
incremento delle prestazioni per includere il riferimento alla tabella stessa.

Il sorgente in plain \LuaTeX{} si semplifica in questo:
\sourcecode{file = [[app-registro/03.tex]]}

Per compilarlo correttamente il file Lua del modulo chiamato
\code{mod-history.lua} deve essere nel percorso di ricerca. La soluzione più
semplice è copiarlo in locale nella directory del sorgente.

A questo punto è facile creare un pacchetto per \LaTeX{}. Non ci sarà alcuna
macro utente ma un aggiunta al codice di chiusura del documento con la macro
\cs{AtEndDocument}. Ecco il codice:
\sourcecode{file = [[app-registro/historylog.sty]]}

Basta caricare il pacchetto e tutte le compilazioni del sorgente verranno
registrate come per questo file sorgente compilabile con Lua\LaTeX{}.
Compilatelo più volte e controllate poi il file locale \file{history.log}:
\sourcecode{file = [[app-registro/doc.tex]]}


\section{Sviluppo}

Abbiamo costruito passo passo un modulo Lua per inserire in un registro alcune
informazioni sulle compilazioni dei sorgenti. Le funzionalità sono minime ma si
tratta di un buon punto di partenza per dare risposta a nuove domande: quale
struttura dovremo dare al modulo in modo che sia semplice aggiungere nuove
funzionalità, come permettere all'utente di modificare le informazioni
registrabili.

A poco a poco prende forma e si precisa la struttura di un \emph{framework}.

%Per esempio, se si vuole che la data sia trascritta nel formato ISO
%\code{yyyy-mm-dd} oppure che la dimensione del file riporti unità di misura
%che si adattano a seconda della magnitudo del valore.

% end of file

