
% esercitazioni semplici con richiami ai fondamenti


\chapter{Let's start with Lua}
\label{chGo}

In questo inizio guida, con \emph{tutorial} intenderemo una sorta di racconto
dei progressi compiuti da un ipotetico utente \LuaTeX{} indaffarato a risolvere
alcuni problemi con i suoi documenti: fare calcoli con una calcolatrice o
comporre una tabella ripetitiva, dandoci l'idea dei nuovi strumenti.


\section{Calcolatrice}

Una calcolatrice, una macro \cs{expr} che accetta un'espressione numerica e
ne stampa il risultato. Sarebbe davvero utile non dover più calcolare a
parte il risultato e riportarlo nel sorgente del nostro documento \LaTeX{}.

Tentiamo qualcosa di molto semplice con Lua: assegnare l'espressione a una
variabile e stamparla nel documento:
\begin{Verbatim}
% !TeX program = LuaLaTeX
% filename: app-start/E0-001-expr.tex
\documentclass{article}
\newcommand\expr[1]{\directlua{
    local result = #1
    tex.print(tostring(result))
}}
\begin{document}
Finalmente una calcolatrice:
\( 1.24 (7.45 + 11.21) = \expr{1.24*(7.45 + 11.21)}\)
\end{document}
\end{Verbatim}

\newcommand\expr[1]{\directlua{
    local result = #1
    tex.print(tostring(result))
}}
compilando con \LuaLaTeX{} il risultato è:
\begin{tcolorbox}
Finalmente una calcolatrice: \( 1.24 (7.45 + 11.21) = \expr{1.24*(7.45 + 11.21)}\)
\end{tcolorbox}

Un buon inizio. Nel sorgente all'interno della macro \cs{directlua} il primo
argomento è stato sostituito con l'espressione che viene poi valutata da Lua.
Nessun pacchetto aggiuntivo caricato, qualsiasi espressione numerica è lecita, e
questo solo e soltanto usando Lua incluso in \LuaTeX.

Funziona anche con i valori booleani \key{true} e \key{false} e con le
stringhe a patto di racchiuderle tra apici. Proviamo:
\begin{tcolorbox}
\verb=\( 56.9 > 78.42 \) è \texttt{\expr{ 56.9 > 78.42 }}=
\tcblower
\( 56.9 > 78.42 \) è \texttt{\expr{ 56.9 > 78.42 }}
\end{tcolorbox}

E se si volessero sostituire le rappresentazioni dei valori vero e falso? Ecco
la modifica:
\begin{Verbatim}
\newcommand\expr[1]{\directlua{
    local result = #1
    if type(result) == "boolean" then
        if result then
            result = "vero"
        else
            result = "falso"
        end
    end
    tex.print(tostring(result))
}}
\end{Verbatim}

\renewcommand\expr[1]{\directlua{
    local result = #1
    if type(result) == 'boolean' then
        if result then
            result = 'vero'
        else
            result = 'falso'
        end
    end
    tex.print(tostring(result))
}}

Un semplice test ci conforterà sulla correttezza del codice:
\begin{tcolorbox}[sidebyside]
\verb|\expr{100 == 100 and 7 > 3}|
\tcblower
\expr{100 == 100 and 7 > 3}
\end{tcolorbox}

Si, funziona. A questo punto vorrei poter regolare l'arrotondamento del
risultato numerico della calcolatrice. Facile se si ricorre a un argomento
opzionale separato dall'espressione da una virgola:
\begin{Verbatim}
\newcommand\expr[1]{\directlua{
    local result, dec = #1
    if type(result) == "boolean" then
        if result then result = "vero" else result = "falso" end
    elseif type(result) == "number" and dec then
        local perc = string.char(37)
        local fmt1 = perc..perc.."0."..perc.."df"
        local fmt2 = string.format(fmt1, dec)
        result = string.format(fmt2, result)
    end
    tex.print(tostring(result))
}}
\end{Verbatim}

\renewcommand\expr[1]{\directlua{
    local result, dec = #1
    if type(result) == 'boolean' then
        if result then result = 'vero' else result = 'falso' end
    elseif type(result) == 'number' and dec then
        local perc = string.char(37)
        local fmt1 = perc..perc..'0.'..perc..'df'
        local fmt2 = string.format(fmt1, dec)
        result = string.format(fmt2, result)
    end
    tex.print(tostring(result))
}}

Il codice stavolta perde un po' di chiarezza per non poter usare direttamente
il carattere percento che verrebbe interpretato come inizio di un commento, nel
costruire la stringhe di formato. Ovviamente questo non succederebbe se il
codice fosse in file separato. Mettiamo alla prova la nuova versione:
\begin{tcolorbox}
\verb|\(\sqrt{2} + \sqrt{3} = \expr{ 2^0.5 + 3^0.5, 2 }\)|
\tcblower
\(\sqrt{2} + \sqrt{3} = \expr{ 2^0.5 + 3^0.5, 2 }\)
\end{tcolorbox}

Tuttavia non è possibile usare nell'espressione funzioni matematiche come seno
e coseno. Se usassimo \verb=\expr{sin(1)^2 + cos(1)^2}= non otterremo il
valore unitario ma un errore.

In Lua quelle funzioni matematiche sono disponibili nella libreria \code{math},
così ci vuole poco a riassegnarle a nomi locali per far si che l'identità
trigonometrica sia un'espressione valida:
\begin{Verbatim}
\newcommand\expr[1]{\directlua{
    local cos = math.cos
    local sin = math.sin
    local result, dec = #1
    if type(result) == "boolean" then
        if result then result = "vero" else result = "falso" end
    elseif type(result) == "number" and dec then
        local perc = string.char(37)
        local fmt1 = perc..perc.."0."..perc.."df"
        local fmt2 = string.format(fmt1, dec)
        result = string.format(fmt2, result)
    end
    tex.print(tostring(result))
}}
\end{Verbatim}

\renewcommand\expr[1]{\directlua{
    local cos = math.cos
    local sin = math.sin
    local result, dec = #1
    if type(result) == 'boolean' then
        if result then result = 'vero' else result = 'falso' end
    elseif type(result) == 'number' and dec then
        local perc = string.char(37)
        local fmt1 = perc..perc..'0.'..perc..'df'
        local fmt2 = string.format(fmt1, dec)
        result = string.format(fmt2, result)
    end
    tex.print(tostring(result))
}}

Una prova della calcolatrice potenziata con le funzioni matematiche ci dirà se
tutto funziona bene:
\begin{tcolorbox}
\begin{Verbatim}
\(\sin^2(1/2) + \cos^2(1/2) = \expr{sin(0.5)^2 + cos(0.5)^2, 8}\).
A \( 1/3 \) l'identità è pari a \( 1 \)?
\emph{\expr{sin(1/3)^2 + cos(1/3)^2 == 1}}
\end{Verbatim}
\tcblower
\(\sin^2(1/2) + \cos^2(1/2) = \expr{sin(0.5)^2 + cos(0.5)^2, 8}\).
A \( 1/3 \) l'identità è pari a \( 1 \)?
\emph{\expr{sin(1/3)^2 + cos(1/3)^2 == 1}}
\end{tcolorbox}

Finora ogni nuova funzionalità aggiunta alla calcolatrice non ha presentato
difficoltà. Possiamo inserire o meno il risultato in ambiente matematico,
arrotondarlo al un numero di decimali desiderato, usare funzioni matematiche.
Lua si sta dimostrando semplice da usare e molto efficace.

Continuamo allora con un nuovo passo: aggiungere costanti numeriche. Per
inserire variabili letterali in un'espressione abbiamo bisogno che il loro
valore numerico sia inizializzato ma non possiamo ricorrere alla stessa
tecnica con cui abbiamo risolto l'inserimento delle funzioni trigonometriche.

Infatti, non è possibile codificare variabili locali senza conoscerne il nome,
perché è un dato che fornirà l'utente. Serve una sorta di metaprogrammazione
come con le macro del linguaggi compilati. Leggendo più a fondo la
documentazione di Lua, si scopre che è possibile intervenire sull'ambiente delle
variabili globali \code{\_ENV} di un \emph{chunk}, anzi, a ben vedere il
problema di rendere visibili simboli di costanti è lo stesso di quello di
rendere disponibili nell'espressione le funzioni matematiche con nomi
abbreviati. Facciamo quindi un tentativo ripartendo con il codice iniziale:
\begin{Verbatim}
\directlua{
calclib = {}
for name, object in pairs(math) do
    calclib[name] = object
end
}
\newcommand\expr[1]{\directlua{
do
    local _ENV = calclib
    ans = #1
end
tex.print(tostring(calclib.ans))
}}
\end{Verbatim}

Un codice che sfrutta una tecnica piuttosto interessante: all'interno di un
blocco riassegnamo localmente la variabile \code{\_ENV} con \code{calclib},
una tabella in cui vi abbiamo copiato tutte le funzioni matematiche della
libreria \code{math} di Lua. Alla riga seguente, tutti quei nomi di funzione
apparterranno alle variabili visibili al momento della valutazione
dell'espressione.

Non solo, come effetto collaterale, il risultato dell'ultimo calcolo sarà
disponibile nella successiva espressione nella variabile \code{ans} come succede
con altri tool matematici! Proviamolo:

\directlua{
calclib = {}
for name, object in pairs(math) do
    calclib[name] = object
end
}
\renewcommand\expr[1]{\directlua{
do
    local _ENV = calclib
    ans = #1
end
tex.print(tostring(calclib.ans))
}}

\begin{tcolorbox}[sidebyside]
\begin{Verbatim}
\expr{pi/4}\\
\expr{cos(ans)}\\
\expr{acos(ans)}
\end{Verbatim}
\tcblower
\expr{pi/4}\\
\expr{cos(ans)}\\
\expr{acos(ans)}
\end{tcolorbox}

Non ci resta che aggiungere la memorizzazione delle costanti. Useremo
l'argomento opzionale della macro, le informazioni tra parentesi quadre, per
fornire all'espressione una serie di costanti nel formato chiave/valore,
ciascuna dichiarazione separata da una virgola. Memorizzeremo le costanti
indicate dall'utente solamente se il loro nome non è già utilizzato, per esempio
da un nome di funzione. Inoltre, specificando una stringa isolata tra le
opzioni, potremo implementare la memorizzazione del risultato così che sia
riutilizzabile nelle successive espressioni. Proviamo con:
\begin{Verbatim}
\directlua{
calclib = {}
for name, object in pairs(math) do
    calclib[name] = object
end
}
\newcommand\expr[2][]{\directlua{
do
    local error, pairs, assert, type = error, pairs, assert, type
    local _ENV = calclib
    local opt = {#1}
    local mem = opt[1]; opt[1] = nil
    for c, val in pairs(opt) do
        if _ENV[c] then
            error("Duplicated key '"..c.."' for constant name")
        else
            _ENV[c] = val
        end
    end
    ans = #2
    if mem then
        assert(type(mem) == "string")
        if _ENV[mem] then
            error("Duplicated key '"..mem.."' for memory index")
        else
            _ENV[mem] = ans
        end
    end
end
tex.print(tostring(calclib.ans))
}}
\end{Verbatim}

\renewcommand\expr[2][]{\directlua{
do
    local error, pairs, assert, type = error, pairs, assert, type
    local _ENV = calclib
    local opt = {#1}
    local mem = opt[1]; opt[1] = nil
    for c, val in pairs(opt) do
        if _ENV[c] then
            error([[Duplicated key ']]..c..[[' for constant name]])
        else
            _ENV[c] = val
        end
    end
    ans = #2
    if mem then
        assert(type(mem) == [[string]])
        if _ENV[mem] then
            error([[Duplicated key ']]..mem..[[' for memory index]])
        else
            _ENV[mem] = ans
        end
    end
end
tex.print(tostring(calclib.ans))
}}

Poiché anche i valori assegnati alle costanti sono valutati da Lua dopo la
modifica dell'environment, anche per le costanti nelle opzioni della macro è
possibile assegnare espressioni usando tutte le funzioni matematiche e tutte le
costanti precedentemente definite. Un ultimo esempio:
\begin{tcolorbox}[sidebyside, righthand width=30mm]
\begin{Verbatim}
\( b = \expr[b = 10]{b} \),\\
\( h = \expr[h = 20]{h} \),\\
\( M = \expr[m = 1000]{m}\),\\
\( \sigma = M/W = \expr[w=(b*h^2)/6]{m/w}\).
\end{Verbatim}
\tcblower
\( b = \expr[b = 10]{b} \),\\
\( h = \expr[h = 20]{h} \),\\
\( M = \expr[m = 1000]{m}\),\\
\( \sigma = M/W = \expr[w=(b*h^2)/6]{m/w}\).
\end{tcolorbox}







\section{Tabella dei pesi}

Se si potesse automatizzare la creazione della tabella dei pesi





