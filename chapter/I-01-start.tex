
% codename "magpie"

\chapter{Let's start with \LuaTeX}
\label{iChStart}

Consideriamo un sorgente \LaTeX{} minimale:
\begin{lines}
#[tex]
% !TeX program = LuaLaTeX
\documentclass{article}
\begin{document}
\end{document}
\end{lines}

I suoi elementi sono: la riga magica, l'utile commento che informa l'editor di
quale compositore usare per la compilazione, la dichiarazione di classe e infine
il corpo del documento vuoto.

Con il compositore \LuaLaTeX{} abbiamo a disposizione la nuova primitiva
\cs{directlua}. La si può inserire più volte e in qualsiasi punto del codice. Se
la inserissimo nel preambolo del sorgente minimo avremo:

\CLRmarginpar{Lua in \LaTeX\\
\gotosec{} \ref{iSecLuaInLuaLaTeX}}[true]% true option means +16pt of vspace
%
\CLRmarginpar{\code{\backslash directlua}\\
\gotosec{} \ref{iSecDirectLua}}
%
\begin{lines}
#[tex]
% !TeX program = LuaLaTeX
\documentclass{article}
\directlua{<codice Lua>}
\begin{document}
\end{document}
\end{lines}

Qui sta il punto. La primitiva \cs{directlua} è come se commutasse il modo di
compilazione da \LaTeX{} a Lua, un linguaggio di programmazione per scopi
generali, efficiente e portabile. Qualsiasi cosa faccia il \code{<codice Lua>}
racchiuso tra graffe, esso sarà eseguito dall'interprete Lua e non da \TeX.

\begin{quotation}
Quali sono le conseguenze? Qual è l'utilità di Lua?
\end{quotation}

\CLRmarginpar{Passare a \LuaLaTeX\\
\gotosec{} \ref{iSecPassareALuaTeX}}
%
La risposta a queste ottime domande è duplice. La prima è che il motore
\prog{luatex} rispetto a \prog{pdftex} è stato migliorato in molti aspetti, per
esempio è in grado di gestire i font di tipo Open Type nativamente. Solo questo
lo rende molto interessante per l'utente.

La seconda è che Lua può \emph{integrare} l'elaborazione \TeX{} eseguendo
compiti complessi come il calcolo numerico, l'interrogazione di database,
l'editing del testo, l'interazione con i servizi di rete, la costruzione di
oggetti tipografici di complessità arbitraria, la grafica vettoriale, eccetera
eccetera. Non è male studiare subito qualche esempio.

Ciò che è importante di questi primi esempi è osservare quanto sia semplice e
utile integrare le funzionalità di base del compositore con Lua. Questo è il
motivo che giustifica un commento del codice qui solo abbozzato. Tutti i
prossimi capitoli della guida hanno lo scopo di approfondire i concetti del
linguaggio Lua e le nuove funzionalità interne.

Infine, a ognuno degli esempi corrisponde un file sorgente disponibile
nell'\href{https://github.com/GuITeX/guidalua}{archivio elettronico della
guida}, pronto per essere compilato e per studiare modifiche e fare esperimenti.


\section{La diagonale di pagina}

Desideriamo che nel nostro documento ci sia un testo allineato sulla diagonale
della pagina. Per ottenerlo usando il comando \cs{rotatebox} del pacchetto
\pack{graphicx} è necessario calcolare il valore dell'angolo di rotazione in
gradi conoscendo la misura di larghezza e altezza della pagina e questo implica
il calcolo dell'arcotangente del rapporto. Nel caso di questa guida:
\[
    \alpha = \frac{180}{\pi}\arctan{\frac{h}{w}} = \directlua{
        local w = tex.pagewidth
        local h = tex.pageheight
        local angle = (180/math.pi) * math.atan(h/w)
        tex.print(tostring(angle))
    }°
\]

Applicando qualche metodo numerico sono certo che \TeX{} sia in grado di
calcolare l'angolo con sufficiente precisione pur non disponendo di alcuna
libreria in virgola mobile. Con Lua invece è un calcolo diretto in floating
point:

\CLRmarginpar{Tabella di Lua\\
\gotosec{} \ref{iiChTabella}}[true]% true option means +16pt of vspace
%
\CLRmarginpar{Libreria \code{math}\\
\gotosec{} \ref{iiSecMathLibrary}}
%
\CLRmarginpar{Variabili locali\\
\gotosec{} \ref{iiSecLocaleGlobale}}
%
\begin{lines}
#[tex]
#[indexfile=code/e0-001.tex]
% filename: code/e0-001.tex
\directlua{
    local w = tex.pagewidth
    local h = tex.pageheight
    local alpha = (180/math.pi) * math.atan(h/w)
    token.set_macro('angdeg', alpha)
}
\end{lines}

Qualche commento sulle quattro linee di codice Lua\footnote{Il listato completo
del sorgente è scaricabile dalla directory \code{code} con il nome di
\file{e0-001.tex} dall'archivio dei sorgenti della guida.}: le prime due
leggono le dimensioni della pagina in due variabili locali --- rappresentano
perciò i dati di ingresso dell'elaborazione --- ma attenzione i campi
\key{pagewidth} e \key{pageheight} della tabella \key{tex}, senza entrare ora
nel dettaglio di cosa sia un campo o una tabella in Lua, non sono valori in sola
lettura di valore pari a quello dei corrispondenti parametri dimensionali. Sono
bensì le dimensioni \cs{pagewidth} e \cs{pageheight} stesse.

La terza linea esegue il calcolo in virgola mobile in doppia precisione e
l'ultima crea la macro \cs{angdeg} con il valore dell'angolo --- rappresenta
percò l'output dell'elaborazione --- esattamente come se fosse stata creata con
\cs{def}.

Nel motore di composizione, Lua ha accesso diretto ai registri dimensionali e ai
contatori e può creare macro. Significa che l'implementazione del motore di
composizione stesso è nativamente interfacciato con Lua.


\newcommand{\ordinanomi}[1]{\directlua{
    local list = {#1}
    table.sort(list)
    tex.print(table.concat(list, ', '))
}}

\section{Ordinamento di una lista}

Abbiamo una lista dei nomi di partecipanti a un evento, ma vorremmo evitare di
ordinarli a mano. La lista si presenta come un elenco separato da virgole dei
nomi (già ordinati): \ordinanomi{'Giacomo', 'Tonio', 'Elena', 'Anna', 'Stefano',
'Milena', 'Federico', 'Giovanni', 'Massimo', 'Basilio', 'Beatrice'}.

In Lua bastano tre righe di codice per definire il comando \cs{ordina} che ha
come unico argomento la lista:

\CLRmarginpar{Libreria \code{table}\\
\gotosec{} \ref{iiSecTableLibrary}}[true]% true option means +16pt of vspace
%
\CLRmarginpar{\fn{tex.print}\\
\gotosec{} \ref{iSecPassaggioDati}}
%
\CLRmarginpar{\fn{table.concat}\\
\gotosec{} \ref{iiSecStringImmutability}}
%
\begin{lines}
#[tex]
#[indexfile=code/e0-002.tex]
% filename: code/e0-002.tex
\newcommand{\ordina}[1]{\directlua{
    local list = {#1}
    table.sort(list)
    tex.print(table.concat(list, ", "))
}}
\end{lines}

Il dato in ingresso, la lista dei nomi non ordinata, viene costruito grazie al
meccanismo della sostituzione degli argomenti di una macro, nel momento in cui
il codice argomento della macro \cs{directlua} viene espanso prima di essere
inviato all'interprete per l'esecuzione.

Il dato in uscita, la lista dei nomi ordinata, arriva al compositore come testo
in lettura come se fosse stato digitato nel file sorgente. Il codice della macro
\cs{ordina} rappresenta quindi una sorta di funzione.

Nel documento un tale comando si usa in questo modo, con i nomi necessariamente
da delimitare come stringhe Lua:
\begin{lines}
#[tex]
#[indexfile=code/e0-002.tex]
% filename: code/e0-002.tex
\ordina{"Giacomo", "Tonio", "Elena", "Anna", "Stefano",
    "Milena", "Federico", "Giovanni", "Massimo", "Basilio",
    "Beatrice"}
\end{lines}

Con qualche riga di codice in più, sarebbe semplice eliminare la necessità della
delimitazione dei nomi, oppure inserire un criterio di ordinamento più complesso
come quello per cognome/nome.


\section{Data in formato ISO}

Le date nel formato ISO~\texttt{yyyy-mm-dd} si convertono facilmente nel formato
esteso a cui siamo abituati, associando ai numeri da 1 a 12 i nomi dei mesi:

\CLRmarginpar{\fn{string.sub}\\
\gotosec{} \ref{iiSecStringOther}}[true]% true option means +16pt of vspace
%
\CLRmarginpar{\key{math.}\\
\fn{tointeger}\\
\gotosec{} \ref{iiSecMathLibrary}}
%
\CLRmarginpar{\fn{assert}\\
\gotosec{} \ref{iiSecTabellaOggetto}}
%
\begin{lines}
#[tex]
#[indexfile=code/e0-003.tex]
% filename: code/e0-003.tex
\newcommand{\isodate}[1]{\directlua{
local isodate = [[#1]]
% conversione numerica della data
local y = assert(math.tointeger(isodate:sub(1,4)))
local m = assert(math.tointeger(isodate:sub(6,7)))
local d = assert(math.tointeger(isodate:sub(9)))
local month = {
   "gennaio", "febbraio", "marzo", "aprile", "maggio",
   "giugno", "luglio", "agosto", "settembre", "ottobre",
   "novembre", "dicembre"
}
% stampa nel formato esteso giorno mese anno
tex.print(d.." "..month[m].." "..y)
}}
\end{lines}

\newcommand{\isodate}[1]{\directlua{
local isodate = [[#1]]
local y = assert(math.tointeger(isodate:sub(1,4)))
local m = assert(math.tointeger(isodate:sub(6,7)))
local d = assert(math.tointeger(isodate:sub(9)))
local month = {
   'gennaio', 'febbraio', 'marzo', 'aprile', 'maggio',
   'giugno', 'luglio', 'agosto', 'settembre', 'ottobre',
   'novembre', 'dicembre'
}
tex.print(d..' '..month[m]..' '..y)
}}

Per esempio, la data di versione di questa guida nel formato ISO è
\code{\guidaluadate} con la semplice macro \cs{isodate} diventa
\isodate{\guidaluadate}. Altri sviluppi interessanti sono il controllo di
validità della data e l'introduzione di più formati oltre a quello esteso.


\section{Inclusione automatica di PDF}

La macro d'esempio \cs{includePDFall} appoggiandosi al pacchetto
\pack{pdfpages}, cerca nella directory corrente tutti i file PDF per unirli in
un documento.

Tra i file della directory corrente è necessario escludere non solo quelli che
non hanno l'estensione cercata, ma anche lo stesso file PDF in compilazione.
Questo il codice Lua della macro leggermente semplificato:

\CLRmarginpar{\key{lfs}\\
\gotosec{} \ref{iSecLuaTeXLibraries}}[true]% true option means +16pt of vspace
%
\CLRmarginpar{\fn{string.match}\\
\gotosec{} \ref{iiSecPattern}}
%
\CLRmarginpar{\key{string.}\\
\fn{format}\\
\gotosec{} \ref{iiSecStringFormat}}
%
\begin{lines}
#[indexfile=code/e0-004.tex]
-- filename: code/e0-004.tex
local path = assert(lfs.currentdir())
local t = {}
local incfmt = "\\includepdf[pages=-]{%s}"
local extfmt = "%.%w+$"
for filename in lfs.dir(path) do
    if (filename:match(extfmt) or ""):lower() == ".pdf" and
        filename ~= "\jobname.pdf" then
        t[#t + 1] = string.format(incfmt, filename)
    end
end
tex.print(t)
\end{lines}

Con la libreria \code{lfs}, Lua File System, si esaminano tutti i file della
directory corrente, quella in cui si trova il sorgente. Per ciascuno di questi
file si estrae l'estensione in minuscolo dal suo nome: se si tratta di un file
PDF si esegue l'ulteriore controllo per escludere il file in compilazione.

I nomi dei file così filtrati sono memorizzati in un array sottoforma di stringa
del comando di inclusione. Al termine, tutti i comandi \cs{includepdf} sono
inviati al flusso d'ingresso del compositore.

Non sarebbe difficile rendere il codice ricorsivo perché cerchi file PDF anche
nelle sotto directory o far in modo di associare a specifici file PDF
particolari opzioni d'inclusione.


\section{Come proseguire da qui}

Il prossimo capitolo~\ref{iChExplain} introduce i motori di composizione
Lua-powered distinguendoli dal formato, spiegando come compilare con essi i
sorgenti \LaTeX{}.

I capitoli dal~\ref{iiChAssignment} fino al~\ref{iiChOop} trattano delle basi
del linguaggio Lua e sono il cuore della guida.

% parte iii cose di luatex
La parte~\ref{partLuaTeX}, Cose di \LuaTeX, tratta delle principali tecnologie
Lua specifiche del compositore come i nodi, i mattoni tipografici che si possono
assemblare in strutture complesse.

Nei capitoli finali della parte~\ref{partApp} dei tutorial applicativi in Lua
mostrano come progettare moduli per gli utenti: per esempio quello sulla
\emph{calcolatrice} (capitolo~\ref{ivChCalcolatrice}) o il tutorial sulla
costruzione automatica di una tabella numerica (capitolo~\ref{ivChTabellaPesi}).

% end of file
